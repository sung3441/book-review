# Chapter4 아키텍처

MySQl 서버의 구조를 아래와 같이 분리할 수 있다.

## MySQL 엔진 아키텍처

### MySQL 엔진 - 사람의 머리 역할 담당
- 커넥션 핸들러, SQL 파서, 전처리기, 옵티마이저가 중심을 이룬다.
- 표준 SQL (ANSI) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.

### 스토리지 엔진 - 손과 발의 역할 담당
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담
- MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 테이블이 사용할 스토리지 엔진을 미리 지정하면, 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 지정한 스토리지 엔진이 처리
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀과 같은 기능을 내장하고 있다.

### 핸들러 API
- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데,
- 이러한 요청을 핸들러 요청이라고 한다. 여기서 사용되는 API를 핸들러 API 라고 한다.
- 이 핸들러 API를 통해 얼마나 많은 데이터 작업이 있었는지 명령어로 확인할 수 있다.

## MySQL 스레딩 구조
- MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동.
- 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있음.
- MySQL 서버에서 실행 중인 스레드의 목록을 데이터 베이스의 threads 테이블을 통해 확인 가능
- 백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있다.
- 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다.

### 포그라운드 스레드 (클라이언트 스레드)
- 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아감
- 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재함
- 이 때 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져옴
- 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어서 작업을 처리
- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리
- 하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록은 백그라운드 스레드가 처리

### 백그라운드 스레드

MyISAM의 경우 해당 사항이 없는 부분이지마느 InnoDB는 여러 가지 작업이 백그라운드로 처리

- Insert 버퍼를 병합하는 스레드
- Log를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

모두 중요한 역할이지만 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드이다.  
MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며,  
innodb_write_io_threads와 innodb_read_io_threads 시스템 변수로 스레드의 개수를 설정한다.  
InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 일반적인 내장 디스크를 사용할 때는  
2~4 정도, DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다